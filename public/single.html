<!DOCTYPE HTML>
<html>
	<head>
		<title>ZombieTown</title>
		<style>
      canvas { 
        width: 100%; height: 100% 
      }

      #progress {
          color:#9900FF;
          top:7em;
          width: 100%;
          font-size:3em;
          font-family: Arial;
          font-weight:bold;
          position:absolute;
          z-index:100;
          text-align: center;
          text-shadow: #000 0px 0px 10px;
          display:none;
      }

      #start {
          color:#009900;
          text-shadow: #000 0px 0px 2px;
          padding:0.1em 0.3em;
          width:3em;
          font-family: Arial;
          text-align: center;
          display:none;
      }

      .shadow {
          /*-moz-box-shadow: 0px 0px 5px #000;*/
          /*-webkit-box-shadow: 0px 0px 5px #000;*/
          box-shadow: 0px 0px 5px #000;
      }

      #progressbar {
        text-align: center;
        background: white;
        width: 250px;
        height: 10px;
      }

      #bar {
        background:#d00;
        width:50px;
        height:10px;
      }

      .enabled {
        color: lime!important;
        cursor:pointer;
      }

      .enabled:hover {
        text-shadow: #0f0 0px 0px 5px !important;
      }

      .disabled {
        background:gray;
        cursor:default;
      }
    </style>
		<script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
		<script src="lib/three.js"></script>
		<script src="js/keyboard.js"></script>
	</head>
	
  <body>
    <div id="progress">
      <span id="loading">Loading ...</span>
      <center>
        <div id="progressbar" class="shadow"><div id="bar" class="shadow"></div></div>
        <div id="start" class="disabled">Start</div>
      </center>
    </div>

    <script src="lib/Detector.js"></script>
    <script src="lib/stats.min.js"></script>
    <script src="lib/BufferGeometryUtils.js"></script>
    <script src="lib/TrackballControls.js"></script>

<!--     <script type="x-shader/x-vertex" id="vertexShader">
      varying vec3 vWorldPosition;
      void main() {
        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
    </script>
    <script type="x-shader/x-fragment" id="fragmentShader">
      uniform vec3 topColor;
      uniform vec3 bottomColor;
      uniform float offset;
      uniform float exponent;

      varying vec3 vWorldPosition;

      void main() {
        float h = normalize( vWorldPosition + offset ).y;
        gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( h, exponent ), 0.0 ) ), 1.0 );
      }
    </script> -->

    <script>
      if ( !Detector.webgl ) Detector.addGetWebGLMessage();
      
      var socket = io.connect();

      // Set up the scene, camera, and renderer as global variables.
      var scene, camera, renderer;
      var cameraControls;
      var stats, container, loaded;
      var clock = new THREE.Clock();
      var toLoad = 2;

      // for animation
      var animOffset    = 0,   // starting frame of animation
        walking         = false,
        duration        = 1000, // milliseconds to complete animation
        keyframes       = 3,   // total number of animation frames
        interpolation   = duration / keyframes, // milliseconds per frame
        lastKeyframe    = 0,    // previous keyframe
        currentKeyframe = 0;
      var time;

      init();
      animate();

      function $( id ) {
        return document.getElementById( id );
      }

      // Sets up the scene.
      function init() {

        // setUpScene(scene, camera);
        var WIDTH = window.innerWidth,
            HEIGHT = window.innerHeight;

        setStats();

        createLoadScene(WIDTH,HEIGHT);

        // Create an event listener that resizes the renderer with the browser window.
        window.addEventListener('resize', function() {
          var WIDTH = window.innerWidth,
              HEIGHT = window.innerHeight;
          renderer.setSize(WIDTH, HEIGHT);
          camera.aspect = WIDTH / HEIGHT;
          camera.updateProjectionMatrix();
        });

        // axes helper
        var axes = new THREE.AxisHelper(200);
          scene.add( axes );

        // Create a renderer and add it to the DOM.
        renderer = new THREE.WebGLRenderer({preserveDrawingBuffer:true});
        // renderer = new THREE.WebGLRenderer( {antialias:true} );
        renderer.setSize(WIDTH, HEIGHT);
        renderer.setClearColor(scene.fog.color, 1);
        renderer.domElement.style.position = "relative";
        document.body.appendChild(renderer.domElement);

        // renderer.gammaInput = true;
        // renderer.gammaOutput = true;
        // renderer.shadowMapEnabled = true;
        // renderer.shadowMapType = THREE.PCFShadowMap;

        // Set load screen
        $( "start" ).addEventListener( 'click', onStartClick, false );
        $( "progress" ).style.display = "block";
        var callbackProgress = function( progress, result ) {
          var bar = 250,
            total = progress.total_models + progress.total_textures,
            loaded = progress.loaded_models + progress.loaded_textures;
          if ( total )
            bar = Math.floor( bar * loaded / total );
          $( "bar" ).style.width = bar + "px";
          count = 0;
          for ( var m in result.materials ) count++;
        }


        // Load in the mesh and add it to the scene.
        var loader = new THREE.JSONLoader();
        // var loader = new THREE.BufferGeometryLoader();
        loader.callbackProgress = callbackProgress;
        loader.load( "assets/models/map1/map1.js", function(geometry, materials){
          // var bufferGeometry = new THREE.BufferGeometryUtils.fromGeometry( geometry );
          // for (var i = 0; i < materials.length; i++){
          //       materials[i].index0AttributeName = "position";
          //     }
          var material = new THREE.MeshFaceMaterial( materials );
          mesh = new THREE.Mesh( geometry, material );
          mesh.position.set( 0, 0, 0 );
          mesh.scale.set(1,1,1);
          // mesh.castShadow = true;
          // mesh.receiveShadow = true;
          scene.add(mesh);
          loadingFinish();
        });

        addCharacters(); 

        // Add OrbitControls so that we can pan around with the mouse.
        // controls = new THREE.OrbitControls(camera, renderer.domElement);
        // CONTROLS
        cameraControls = new THREE.TrackballControls( camera, renderer.domElement );
        var delta = clock.getDelta();
        cameraControls.update( delta );

        setInterval(timer, 1000);

      }

      function createLoadScene(WIDTH, HEIGHT) {
        // Create the scene and set the scene size.
        scene = new THREE.Scene();

        // Create a camera, zoom it out from the model a bit, and add it to the scene.
        camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 1, 20000);
        camera.position.set(0,20,50);
        scene.add(camera);

        // Lightings
        setLights();
      }

      function onStartClick() {
        $( "progress" ).style.display = "none";
      }

      function setStats(){
        container = document.createElement( 'div' );
        document.body.appendChild( container );
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        stats.domElement.style.zIndex = 100;
        container.appendChild( stats.domElement );
      }

      function loadingFinish(){
        toLoad = toLoad - 1;
        if(toLoad === 0){
          $( "loading" ).style.display = "none";
          $( "progressbar" ).style.display = "none";
          $( "start" ).style.display = "block";
          $( "start" ).className = "enabled";
        }
      }

      function setLights(){
        // Fog
        scene.fog = new THREE.Fog( 0x9999FF, 20, 500);

        // Lightings
        var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 1 );
          hemiLight.color.setHSL( 0.6, 1, 0.75 );
          hemiLight.groundColor.setHSL( 0.1, 0.8, 0.7 );
          hemiLight.position.y = 500;
          hemiLight.position.x = 400;
          scene.add( hemiLight );
        
        var light = new THREE.SpotLight( 0xffffff, 1, 0, Math.PI / 2, 1 );
          light.position.set( 300, 1000, 1200);
          light.target.position.set( 0, 0, 0 );

          // light.castShadow = true;
          light.intensity = 1;

          // light.shadowCameraFov = 10;
          // light.shadowCameraVisible = true;
          // light.shadowDarkness = 0.5;
          // light.shadowMapWidth = 1024;
          // light.shadowMapHeight = 768;
          scene.add(light);
        
        // SKYDOME
        // var vertexShader = document.getElementById( 'vertexShader' ).textContent;
        // var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
        // var uniforms = {
        //   topColor:    { type: "c", value: new THREE.Color( 0x000000) },
        //   bottomColor: { type: "c", value: new THREE.Color( 0x9999ff) },
        //   offset:    { type: "f", value: 400 },
        //   exponent:  { type: "f", value: 0.6 }
        // }
        // uniforms.topColor.value.copy( hemiLight.color );

        // scene.fog.color.copy( uniforms.bottomColor.value );

        // var skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
        // var skyMat = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide } );

        // var sky = new THREE.Mesh( skyGeo, skyMat );
        // scene.add( sky );  
      }

  /*
  *********************************************************************************************************************
  *********************************************************************************************************************
  */
        var zombie,
          slayer,
          clientid,
          clienttype, 
          room,
          keyPressed,
          humans = [],
          humanHit = false, 
          timerTicks = 0,
          opponentHit = false,
          wallHit = false, 
          count = 120,
          score = 0; 

        function addCharacters () {

          var loader = new THREE.JSONLoader();
            loader.load( "assets/models/zombie/zombiefinal.js", function(geometry, materials){

              // var bufferGeometry = new THREE.BufferGeometryUtils.fromGeometry( geometry );
              geometry.computeMorphNormals();
              zombie = new THREE.MorphAnimMesh( geometry, new THREE.MeshFaceMaterial( materials ) );
              zombie.position.set( 0, 0, 0 );
              zombie.scale.set(1,1,1);
              // zombie.castShadow = true;
              scene.add(zombie);
              camera.lookAt(zombie.position);
              zombie.add(camera);
              loadingFinish();

              mesh.parseAnimations();

              mesh.playAnimation( geometry.firstAnimation, scope.animationFPS );
              mesh.baseDuration = mesh.duration;
            });

          var geometry = new THREE.BoxGeometry(5, 5, 5);
          var material = new THREE.MeshBasicMaterial({color: 0xffb4d9});
          slayer = new THREE.Mesh(geometry, material);
          slayer.position.x = 15;
          slayer.position.z = 15;
          slayer.position.y = 2.5;
          scene.add(slayer);
          // loadingFinish();

          socket.on('message', function(obj) {
            if('humans' in obj) {
              var i;
              for(i = 0; i < (obj.humans).length; i++) {
                humans.push(obj.humans[i]);
                var geometry = new THREE.BoxGeometry(5, 5, 5);
                var material = new THREE.MeshBasicMaterial({color: 0xF5D0A9});
                humans[i] = new THREE.Mesh(geometry, material);
                humans[i].position.y = 2.5;
                humans[i].position.x = -40;
                humans[i].position.z = 20;
                humans[i].turned = false;
                scene.add(humans[i]);
              }
            }
          });

        }


        socket.on('connect', function() {
          console.log('connect');
        });

        socket.on('message', function(obj) {

          if('playerDisconnect' in obj) {
            console.log(obj.playerDisconnect + 'disconnected');
            if(obj.playerDisconnect%2 === 0) {
              scene.remove(zombie);
            } else {
              scene.remove(slayer);
            }
          }
        });

        function movement() {
          walking = false;
          // timerTicks++; 

          // if (timerTicks === 10) {
          //   humans.forEach(function(human) {
          //     human.position.x += 1; 
          //   });
          //   timerTicks = 0; 
          // }
            if(Key.isDown(Key.A)) {
                keyPressed = 'A';
                walking = true;
                if(!inSolidRange(keyPressed)){
                  zombie.position.x -= 2;
                } else {
                  if(!humanHit && opponentHit) {
                    socket.send({'gameOverSingle': [clientid]});
                    socket.send({'scoreSingle': score});
                    scene.remove(zombie);
                  } else if(!wallHit && humanHit) {
                    score += 1;
                    console.log('score is ' + score);
                    humanHit = false;
                  }
                }
            }
            if(Key.isDown(Key.W)) {
              walking = true;
              keyPressed = 'W';
                if(!inSolidRange(keyPressed)){
                  zombie.position.z += 2;
                } else if(!wallHit) {
                  if(!humanHit && opponentHit) {
                    socket.send({'gameOverSingle': [clientid]});
                    socket.send({'scoreSingle': score});                    
                    scene.remove(zombie);
                  } else if(!wallHit && humanHit){
                    score += 1;
                    console.log('score is ' + score);
                    humanHit = false;
                  }
                }
            }
            if(Key.isDown(Key.S)) {
              walking = true;
              keyPressed = 'S';
              if(!inSolidRange(keyPressed)){
                zombie.position.z -= 2;
                } else {
                  if(!humanHit && opponentHit) {
                    socket.send({'gameOverSingle': [clientid]});
                    socket.send({'scoreSingle': score});                    
                    scene.remove(zombie);
                    alive = false;
                  } else if(!wallHit && humanHit) {
                    score += 1;
                    console.log('score is ' + score);
                    humanHit = false;
                  }
                }
              }
              if(Key.isDown(Key.D)) {
                walking = true;
                keyPressed = 'D';
                if(!inSolidRange(keyPressed)) {
                    zombie.position.x += 2;
                } else {
                  if(!humanHit && opponentHit) {
                    socket.send({'gameOverSingle': [clientid]});
                    socket.send({'scoreSingle': score});                    
                    scene.remove(zombie);
                    alive = false;
                  } else if(!wallHit && humanHit) {
                    score += 1;
                    console.log('score is ' + score);
                    humanHit = false;
                  }
                }
              }
        }

        function inSolidRange(keyPressed) {

          var slayerPosX = slayer.position.x,
            slayerPosY = slayer.position.z,
            zombiePosX = zombie.position.x,
            zombiePosY = zombie.position.z;

            switch(keyPressed) {
              case 'W' : return inViolation(zombiePosX, zombiePosY + 2, slayer.position, 'W');
              case 'S' : return inViolation(zombiePosX,  zombiePosY - 2, slayer.position, 'S');
              case 'A' : return inViolation(zombiePosX - 2,  zombiePosY, slayer.position, 'A');
              case 'D' : return inViolation(zombiePosX + 2,  zombiePosY, slayer.position, 'D');
            }
        }

        function inViolation(newPlayerX, newPlayerY, opponentPos, dir) {
          console.log('Number of humans: ' + humans.length);
          var i;
          for(i = 0; i < humans.length; i++) {
            if (((dir === 'A') || (dir === 'D')) && 
              (newPlayerX < humans[i].position.x + 5) && (newPlayerX > humans[i].position.x - 5) && 
              (newPlayerY < humans[i].position.z + 5) && (newPlayerY > humans[i].position.z - 5)) {
              console.log("Violating in X domain.\n");

              if(!humans[i].turned) {
                humanHit = true;
                humans[i].material.color.setHex(0x4B088A);
                humans[i].turned = true;
            }
            return true; 

            } else if (((dir === 'W') || (dir === 'S')) && 
              (newPlayerY < humans[i].position.z + 5) && (newPlayerY > humans[i].position.z - 5) && 
              (newPlayerX < humans[i].position.x + 5) && (newPlayerX > humans[i].position.x - 5)) {
              console.log("Violating in Y domain.\n");

                if(!humans[i].turned) {
                  humanHit = true;
                  humans[i].material.color.setHex(0x4B088A);
                  humans[i].turned = true;
                }
                return true; 
             }
          }

          if (((dir === 'A') || (dir === 'D')) && 
            (newPlayerX < opponentPos.x + 5) && (newPlayerX > opponentPos.x - 5) && 
            (newPlayerY < opponentPos.z + 5) && (newPlayerY > opponentPos.z - 5)) {
            console.log("Violating in X domain.\n");

            opponentHit = true;
            return true;

          } else if (((dir === 'W') || (dir === 'S')) && 
            (newPlayerY < opponentPos.z + 5) && (newPlayerY > opponentPos.z - 5) && 
            (newPlayerX < opponentPos.x + 5) && (newPlayerX > opponentPos.x - 5)) {
            console.log("Violating in Y domain.\n");

            opponentHit = true;
            return true; 
          } else if(newPlayerX === 296 || newPlayerX === -296 || newPlayerY === 296 || newPlayerY === -296) {
                wallHit = true;
                return true;
          } else {
            console.log("Not violating.\n"); 
            return false; 
          }
        }

        function timer() {
          count -= 1;
          if(count <= 0) {
            clearInterval(count);
            return;
          } 
          //do something here to show timer updating??? ----------------------------------------
          document.getElementById("timer").innerHTML=count + " secs";
        }

      // Renders the scene and updates the render as needed.
      function animate() {

        // Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
        requestAnimationFrame(animate);
        
        // walkingAnimation();

        // Render the scene.
        renderer.render(scene, camera);
        cameraControls.update();
        stats.update();
        movement();

      }

      function walkingAnimation(){
        if ( zombie && walking ) // exists / is loaded 
          {
            // Alternate morph targets
            time = new Date().getTime() % duration;
            keyframe = Math.floor( time / interpolation ) + animOffset;
            if ( keyframe != currentKeyframe ) 
            {
              zombie.morphTargetInfluences[ lastKeyframe ] = 0;
              zombie.morphTargetInfluences[ currentKeyframe ] = 1;
              zombie.morphTargetInfluences[ keyframe ] = 0;
              lastKeyframe = currentKeyframe;
              currentKeyframe = keyframe;
            }
            zombie.morphTargetInfluences[ keyframe ] = 
              ( time % interpolation ) / interpolation;
            zombie.morphTargetInfluences[ lastKeyframe ] = 
              1 - zombie.morphTargetInfluences[ keyframe ];
          }
      }

    </script>
    <span id="timer"></span>
    <span id="score"></span>
	</body>
</html>